// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

use crate::{
    flavor::MoveFlavor,
    graph::PackageGraph,
    package::{
        EnvironmentName, Package, RootPackage, lockfile::DependencyInfo, paths::PackagePath,
    },
};

use move_bytecode_source_map::utils::{serialize_to_json, serialize_to_json_string};

use anyhow::{Result, bail};
use clap::Parser;
use move_binary_format::CompiledModule;
use move_bytecode_utils::Modules;
use move_command_line_common::files::{
    DEBUG_INFO_EXTENSION, MOVE_BYTECODE_EXTENSION, MOVE_COMPILED_EXTENSION, MOVE_EXTENSION,
    extension_equals, find_filenames, find_move_filenames,
};
use move_compiler::{
    compiled_unit::CompiledUnit,
    diagnostics::{
        Diagnostics, report_diagnostics_to_buffer, report_warnings,
        warning_filters::WarningFiltersBuilder,
    },
    linters::{LINT_WARNING_PREFIX, LintLevel},
    shared::{
        PackageConfig, PackagePaths, SaveFlag, SaveHook,
        files::{FileName, MappedFiles},
    },
};
use move_core_types::{identifier::Identifier, parsing::address::NumericalAddress};
use move_disassembler::disassembler::Disassembler;
use move_docgen::{Docgen, DocgenFlags, DocgenOptions};
use move_model_2::source_model;
use move_package::{
    compilation::{compiled_package::ModuleFormat, package_layout::CompiledPackageLayout},
    source_package::layout::SourcePackageLayout,
};
use move_symbol_pool::Symbol;
use serde::{Deserialize, Serialize};
use std::{
    collections::{BTreeMap, BTreeSet, HashSet},
    fmt,
    io::Write,
    path::{Path, PathBuf},
};

/// References file for documentation generation
pub const REFERENCE_TEMPLATE_FILENAME: &str = "references.md";

// #[derive(Debug, Serialize, Deserialize, Clone)]
// pub struct BuildConfig {
//     pub save_disassembly: bool,
//     pub save_docs: bool,
// }
#[derive(Debug, Parser, Clone, Serialize, Deserialize, Eq, PartialEq, PartialOrd, Default)]
#[clap(about)]
pub struct BuildConfig {
    /// Generate documentation for packages
    #[clap(name = "generate-docs", long = "doc", global = true)]
    pub generate_docs: bool,

    /// Save disassembly for generated bytecode along with
    /// bytecode maps (source maps for disassembeld bytecode)
    #[clap(name = "save-disassembly", long = "disassemble", global = true)]
    pub save_disassembly: bool,

    /// Installation directory for compiled artifacts. Defaults to current directory.
    #[clap(long = "install-dir", global = true)]
    pub install_dir: Option<PathBuf>,

    /// Force recompilation of all packages
    #[clap(name = "force-recompilation", long = "force", global = true)]
    pub force_recompilation: bool,

    /// Optional location to save the lock file to, if package resolution succeeds.
    #[clap(skip)]
    pub lock_file: Option<PathBuf>,

    /// If set, ignore any compiler warnings
    #[clap(long = move_compiler::command_line::SILENCE_WARNINGS, global = true)]
    pub silence_warnings: bool,

    /// If set, warnings become errors
    #[clap(long = move_compiler::command_line::WARNINGS_ARE_ERRORS, global = true)]
    pub warnings_are_errors: bool,

    /// If set, reports errors at JSON
    #[clap(long = move_compiler::command_line::JSON_ERRORS, global = true)]
    pub json_errors: bool,

    #[clap(flatten)]
    pub lint_flag: LintFlag,

    // /// Additional dependencies to be automatically included in every package
    // #[clap(skip)]
    // pub implicit_dependencies: Dependencies,
    /// Forces use of lock file without checking if it needs to be updated
    /// (regenerates it only if it doesn't exist)
    #[clap(skip)]
    pub force_lock_file: bool,
}

#[derive(
    Parser, Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, PartialOrd, Default,
)]
pub struct LintFlag {
    /// If `true`, disable linters
    #[clap(
        name = "no-lint",
        long = "no-lint",
        global = true,
        group = "lint-level"
    )]
    no_lint: bool,

    /// If `true`, enables extra linters
    #[clap(name = "lint", long = "lint", global = true, group = "lint-level")]
    lint: bool,
}

impl LintFlag {
    pub const LEVEL_NONE: Self = Self {
        no_lint: true,
        lint: false,
    };
    pub const LEVEL_DEFAULT: Self = Self {
        no_lint: false,
        lint: false,
    };
    pub const LEVEL_ALL: Self = Self {
        no_lint: false,
        lint: true,
    };

    pub fn get(self) -> LintLevel {
        match self {
            Self::LEVEL_NONE => LintLevel::None,
            Self::LEVEL_DEFAULT => LintLevel::Default,
            Self::LEVEL_ALL => LintLevel::All,
            _ => unreachable!(),
        }
    }

    pub fn set(&mut self, level: LintLevel) {
        *self = level.into();
    }
}

impl From<LintLevel> for LintFlag {
    fn from(level: LintLevel) -> Self {
        match level {
            LintLevel::None => Self::LEVEL_NONE,
            LintLevel::Default => Self::LEVEL_DEFAULT,
            LintLevel::All => Self::LEVEL_ALL,
        }
    }
}

pub struct CompiledPackage<F: MoveFlavor> {
    root_pkg: RootPackage<F>,
    compiled_package_info: CompiledPackageInfo,
    root_compiled_units: Vec<CompiledUnitWithSource>,
    deps_compiled_units: Vec<(Symbol, CompiledUnitWithSource)>,
    compiled_docs: Option<Vec<(String, String)>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompiledPackageInfo {
    /// The name of the compiled package
    pub package_name: Symbol,
    /// The instantiations for all named addresses that were used for compilation
    // pub address_alias_instantiation: BTreeMap<String, String>,
    /// The hash of the source directory at the time of compilation. `None` if the source for this
    /// package is not available/this package was not compiled.
    // pub source_digest: Option<String>,
    /// The build flags that were used when compiling this package.
    pub build_flags: BuildConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OnDiskPackage {
    /// Information about the package and the specific compilation that was done.
    pub compiled_package_info: CompiledPackageInfo,
    /// Dependency names for this package.
    pub dependencies: Vec<Symbol>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OnDiskCompiledPackage {
    /// Path to the root of the package and its data on disk. Relative to/rooted at the directory
    /// containing the `Move.toml` file for this package.
    pub root_path: PathBuf,
    pub package: OnDiskPackage,
}

#[derive(Debug, Clone)]
pub struct CompiledUnitWithSource {
    pub unit: CompiledUnit,
    pub source_path: PathBuf,
}

impl<F: MoveFlavor> CompiledPackage<F> {
    pub fn get_all_compiled_units_with_source(
        &self,
    ) -> impl Iterator<Item = &CompiledUnitWithSource> {
        self.root_compiled_units
            .iter()
            .chain(self.deps_compiled_units.iter().map(|(_, unit)| unit))
    }
    pub fn get_modules_and_deps(&self) -> impl Iterator<Item = &CompiledModule> {
        self.get_all_compiled_units_with_source()
            .map(|m| &m.unit.module)
        // TODO we're ditching bytecode deps support, so maybe this is not needed.
        // .chain(self.bytecode_deps.iter().map(|(_, m)| m))
        // this might need a chain with bytecode_deps.
    }

    pub fn root_modules_map(&self) -> Modules {
        Modules::new(
            self.root_compiled_units
                .iter()
                .map(|unit| &unit.unit.module),
        )
    }

    /// Return the bytecode modules in this package, topologically sorted in dependency order.
    /// Optionally include dependencies that have not been published (are at address 0x0), if
    /// `with_unpublished_deps` is true. This is the function to call if you would like to publish
    /// or statically analyze the modules.
    pub fn get_dependency_sorted_modules(&self) -> Vec<CompiledModule> {
        let all_modules = Modules::new(self.get_modules_and_deps());

        // SAFETY: package built successfully
        let modules = all_modules.compute_topological_order().unwrap();

        // Collect all module IDs from the current package to be published (module names are not
        // sufficient as we may have modules with the same names in user code and in Sui
        // framework which would result in the latter being pulled into a set of modules to be
        // published).
        let self_modules: HashSet<_> = self
            .root_modules_map()
            .iter_modules()
            .iter()
            .map(|m| m.self_id())
            .collect();

        modules
            .filter(|module| self_modules.contains(&module.self_id()))
            .cloned()
            .collect()
    }

    /// Return a serialized representation of the bytecode modules in this package, topologically sorted in dependency order
    pub fn get_package_bytes(&self) -> Vec<Vec<u8>> {
        self.get_dependency_sorted_modules()
            .iter()
            .map(|m| {
                let mut bytes = Vec::new();
                m.serialize_with_version(m.version, &mut bytes).unwrap(); // safe because package built successfully
                bytes
            })
            .collect()
    }
}

impl OnDiskCompiledPackage {
    /// Save `bytes` under `path_under` relative to the package on disk
    pub(crate) fn save_under(&self, file: impl AsRef<Path>, bytes: &[u8]) -> anyhow::Result<()> {
        let path_to_save = self.root_path.join(file);
        let parent = path_to_save.parent().unwrap();
        std::fs::create_dir_all(parent)?;
        std::fs::write(path_to_save, bytes).map_err(|err| err.into())
    }

    fn save_disassembly_to_disk(
        &self,
        package_name: Symbol,
        unit: &CompiledUnitWithSource,
    ) -> anyhow::Result<()> {
        let root_package = self.package.compiled_package_info.package_name;
        assert!(self.root_path.ends_with(root_package.as_str()));
        let disassembly_dir = CompiledPackageLayout::Disassembly.path();
        let file_path = if root_package == package_name {
            PathBuf::new()
        } else {
            CompiledPackageLayout::Dependencies
                .path()
                .join(package_name.as_str())
        }
        .join(unit.unit.name.as_str());
        let d = Disassembler::from_unit(&unit.unit);
        let (disassembled_string, mut bytecode_map) = d.disassemble_with_source_map()?;
        let disassembly_file_path = disassembly_dir
            .join(&file_path)
            .with_extension(MOVE_BYTECODE_EXTENSION);
        self.save_under(
            disassembly_file_path.clone(),
            disassembled_string.as_bytes(),
        )?;
        // unwrap below is safe as we just successfully saved a file at disassembly_file_path
        if let Ok(p) =
            dunce::canonicalize(self.root_path.join(disassembly_file_path).parent().unwrap())
        {
            bytecode_map
                .set_from_file_path(p.join(&file_path).with_extension(MOVE_BYTECODE_EXTENSION));
        }
        self.save_under(
            disassembly_dir.join(&file_path).with_extension("json"),
            serialize_to_json_string(&bytecode_map)?.as_bytes(),
        )
    }

    fn save_compiled_unit(
        &self,
        package_name: Symbol,
        compiled_unit: &CompiledUnitWithSource,
    ) -> anyhow::Result<()> {
        let root_package = &self.package.compiled_package_info.package_name;
        // assert!(self.root_path.ends_with(root_package.as_str()));
        let category_dir = CompiledPackageLayout::CompiledModules.path();
        let root_pkg_name: Symbol = root_package.as_str().into();
        let file_path = if root_pkg_name == package_name {
            PathBuf::new()
        } else {
            CompiledPackageLayout::Dependencies
                .path()
                .join(package_name.as_str())
        }
        .join(compiled_unit.unit.name.as_str());

        self.save_under(
            category_dir
                .join(&file_path)
                .with_extension(MOVE_COMPILED_EXTENSION),
            compiled_unit.unit.serialize().as_slice(),
        )?;
        self.save_under(
            CompiledPackageLayout::DebugInfo
                .path()
                .join(&file_path)
                .with_extension(DEBUG_INFO_EXTENSION),
            compiled_unit.unit.serialize_source_map().as_slice(),
        )?;
        self.save_under(
            CompiledPackageLayout::DebugInfo
                .path()
                .join(&file_path)
                .with_extension("json"),
            &serialize_to_json(&compiled_unit.unit.source_map)?,
        )?;
        self.save_under(
            CompiledPackageLayout::Sources
                .path()
                .join(&file_path)
                .with_extension(MOVE_EXTENSION),
            std::fs::read_to_string(&compiled_unit.source_path)?.as_bytes(),
        )
    }
}

fn build_docs(
    docgen_flags: DocgenFlags,
    package_name: Symbol,
    model: &source_model::Model,
    package_root: &Path,
    deps: &[Symbol],
    install_dir: &Option<PathBuf>,
) -> Result<Vec<(String, String)>> {
    let root_doc_templates = find_filenames(
        &[package_root
            .join(SourcePackageLayout::DocTemplates.path())
            .to_string_lossy()
            .to_string()],
        |path| extension_equals(path, "md"),
    )
    .unwrap_or_else(|_| vec![]);
    let root_for_docs = if let Some(install_dir) = install_dir {
        install_dir.join(CompiledPackageLayout::Root.path())
    } else {
        CompiledPackageLayout::Root.path().to_path_buf()
    };
    let dep_paths = deps
        .iter()
        .map(|dep_name| {
            root_for_docs
                .join(CompiledPackageLayout::CompiledDocs.path())
                .join(dep_name.as_str())
                .to_string_lossy()
                .to_string()
        })
        .collect();
    let in_pkg_doc_path = root_for_docs
        .join(CompiledPackageLayout::CompiledDocs.path())
        .join(package_name.as_str());
    let references_path = package_root
        .join(SourcePackageLayout::DocTemplates.path())
        .join(REFERENCE_TEMPLATE_FILENAME);
    let references_file = if references_path.exists() {
        Some(references_path.to_string_lossy().to_string())
    } else {
        None
    };
    let doc_options = DocgenOptions {
        doc_path: dep_paths,
        output_directory: in_pkg_doc_path.to_string_lossy().to_string(),
        root_doc_templates,
        compile_relative_to_output_dir: true,
        references_file,
        flags: docgen_flags,
    };
    let docgen = Docgen::new(model, &doc_options);
    docgen.generate(model)
}

pub async fn compile<F: MoveFlavor>(
    root_pkg: RootPackage<F>,
    build_config: BuildConfig,
    env: &EnvironmentName,
) -> Result<CompiledPackage<F>> {
    let pkgs = BTreeSet::from(["Sui", "SuiSystem", "MoveStdlib"]);
    let default_addresses = BTreeMap::from([
        (
            Symbol::from("std"),
            NumericalAddress::parse_str("0x1").unwrap(),
        ),
        (
            Symbol::from("sui"),
            NumericalAddress::parse_str("0x2").unwrap(),
        ),
        (
            Symbol::from("sui_system"),
            NumericalAddress::parse_str("0x3").unwrap(),
        ),
    ]);

    let mut starting_addr = 9010;

    let mut named_address_map: BTreeMap<Symbol, NumericalAddress> = BTreeMap::new();
    let root_pkg_paths = find_move_filenames(&[root_pkg.package_path().path().as_path()], false)
        .unwrap()
        .into_iter()
        .map(FileName::from)
        .collect::<Vec<_>>();

    let program_info_hook = SaveHook::new([SaveFlag::TypingInfo]);

    if let Some(dependency_graph) = &root_pkg.dependencies().get(env) {
        let mut dependencies_paths = vec![];
        let nodes = dependency_graph.nodes();

        // Find the source paths for each dependency and build the PackagePaths
        for node in nodes {
            println!("Building dependency: {}", node.package.name());
            let sources = get_sources(node.package.path())?;
            let is_dependency = if node.package.name() == root_pkg.package_name() {
                false
            } else {
                true
            };

            starting_addr = starting_addr + 1;
            let pkg_name: Symbol = node.package.name().as_str().into();
            let addr = NumericalAddress::parse_str(&format!("0x{starting_addr}")).expect("fine");
            let named_address_map = if pkgs.contains(node.package.name().as_str()) {
                default_addresses.clone()
            } else {
                let mut addresses = BTreeMap::from(default_addresses.clone());
                addresses.extend([(pkg_name, addr)]);
                addresses
            };

            // TODO: probably here we need to use a different type than Symbol
            let source_package_paths: PackagePaths<Symbol, Symbol> = PackagePaths {
                name: Some((
                    node.package.name().as_str().into(),
                    PackageConfig {
                        is_dependency: true,
                        warning_filter: WarningFiltersBuilder::new_for_source(),
                        // TODO: we need to use this probably in the manifest for deserialization
                        flavor: move_compiler::editions::Flavor::Sui,
                        // TODO: we should add this to the type in the manifest.
                        edition: move_compiler::editions::Edition {
                            edition: root_pkg.edition().into(),
                            // TODO: should we have this as a field?
                            release: None,
                        },
                    },
                )),
                named_address_map,
                paths: sources,
            };

            dependencies_paths.push(source_package_paths);
        }

        // Compile the root package and its dependencies
        let compiler =
            move_compiler::Compiler::from_package_paths(None, dependencies_paths, vec![])?;
        let compiler = compiler.add_save_hook(&program_info_hook);

        let (files, units_res) = compiler.build()?;
        let data: (MappedFiles, Vec<_>) = match units_res {
            Ok((units, warning_diags)) => {
                decorate_warnings(warning_diags, Some(&files));
                ((files, units))
            }
            Err(error_diags) => {
                // with errors present don't even try decorating warnings output to avoid
                // clutter
                assert!(!error_diags.is_empty());
                let diags_buf =
                    report_diagnostics_to_buffer(&files, error_diags, /* color */ true);
                if let Err(err) = std::io::stderr().write_all(&diags_buf) {
                    anyhow::bail!("Cannot output compiler diagnostics: {}", err);
                }
                anyhow::bail!("Compilation error");
            }
        };

        let root_package_name = root_pkg.package_name().as_str().into();

        let all_compiled_units = data.1;
        let file_map = data.0;
        let mut all_compiled_units_vec = vec![];
        let mut root_compiled_units = vec![];
        let mut deps_compiled_units = vec![];

        for mut annot_unit in all_compiled_units {
            let source_path = PathBuf::from(
                file_map
                    .get(&annot_unit.loc().file_hash())
                    .unwrap()
                    .0
                    .as_str(),
            );
            let package_name = annot_unit.named_module.package_name.unwrap();
            // unwraps below are safe as the source path exists (or must have existed at some point)
            // so it would be syntactically correct
            let file_name = PathBuf::from(source_path.file_name().unwrap());
            if let Ok(p) = dunce::canonicalize(source_path.parent().unwrap()) {
                annot_unit
                    .named_module
                    .source_map
                    .set_from_file_path(p.join(file_name));
            }
            let unit = CompiledUnitWithSource {
                unit: annot_unit.named_module,
                source_path,
            };
            if package_name == root_package_name {
                root_compiled_units.push(unit.clone())
            } else {
                deps_compiled_units.push((package_name, unit.clone()))
            }
            all_compiled_units_vec.push((unit.source_path, unit.unit));
        }

        let mut compiled_docs = None;

        // TODO: probably we want a separate command for this rather than doing it as part of
        // compilation
        if build_config.generate_docs {
            // TODO: fix this root_name_address_map
            let root_named_address_map = BTreeMap::new();
            let program_info = program_info_hook.take_typing_info();
            let model = source_model::Model::from_source(
                file_map.clone(),
                Some(root_package_name),
                root_named_address_map,
                program_info,
                all_compiled_units_vec,
            )?;

            // let direct_deps = root_pkg.direct_dependencies_by_env(env)

            compiled_docs = Some(build_docs(
                DocgenFlags::default(), // TODO this should be configurable
                root_package_name,
                &model,
                root_pkg.package_path().path(),
                //TODO Fix this, it needs immediate dependencies for this pkg
                &[],
                // &immediate_dependencies,
                &build_config.install_dir,
            )?);
        };

        let compiled_package_info = CompiledPackageInfo {
            package_name: root_package_name,
            // // TODO: correct address alias instantiation
            // address_alias_instantiation: BTreeMap::new(),
            // TODO: compute source digest
            // source_digest: None,
            build_flags: build_config.clone(),
        };

        let under_path = root_pkg.package_path().path().join("build");
        let root_package_name: Symbol = root_pkg.package_name().as_str().into();

        save_to_disk::<F>(
            root_compiled_units.clone(),
            compiled_package_info.clone(),
            deps_compiled_units.clone(),
            compiled_docs,
            root_package_name,
            under_path,
        );

        let compiled_package = CompiledPackage {
            compiled_package_info,
            root_compiled_units,
            deps_compiled_units,
            compiled_docs: None,
            // compiled_docs,
            root_pkg,
        };

        Ok(compiled_package)
    } else {
        bail!("Could not compiled package for {env} env")
    }
}

fn find_default_address<'a>(
    pkg_name: &Identifier,
    default_addresses: &'a BTreeMap<Symbol, NumericalAddress>,
) -> Option<&'a NumericalAddress> {
    let std = Identifier::from_utf8("MoveStdlib".into()).unwrap();
    let sui = Identifier::from_utf8("Sui".into()).unwrap();
    let system = Identifier::from_utf8("SuiSystem".into()).unwrap();
    match pkg_name {
        std => default_addresses.get(&("std".into())),
        sui => default_addresses.get(&("sui".into())),
        system => default_addresses.get(&("sui_system".into())),
    }
}

pub(crate) fn save_to_disk<F: MoveFlavor>(
    root_compiled_units: Vec<CompiledUnitWithSource>,
    compiled_package_info: CompiledPackageInfo,
    deps_compiled_units: Vec<(Symbol, CompiledUnitWithSource)>,
    compiled_docs: Option<Vec<(String, String)>>,
    root_package: Symbol,
    under_path: PathBuf,
) -> anyhow::Result<OnDiskCompiledPackage> {
    // self.check_filepaths_ok()?;
    assert!(under_path.ends_with(CompiledPackageLayout::Root.path()));
    let on_disk_package = OnDiskCompiledPackage {
        root_path: under_path.join(root_package.to_string()),
        package: OnDiskPackage {
            compiled_package_info: compiled_package_info.clone(),
            dependencies: deps_compiled_units
                .iter()
                .map(|(package_name, _)| package_name.clone())
                .collect::<BTreeSet<_>>()
                .into_iter()
                .collect(),
        },
    };

    // Clear out the build dir for this package so we don't keep artifacts from previous
    // compilations
    if on_disk_package.root_path.is_dir() {
        std::fs::remove_dir_all(&on_disk_package.root_path)?;
    }

    std::fs::create_dir_all(&on_disk_package.root_path)?;

    for compiled_unit in root_compiled_units {
        on_disk_package.save_compiled_unit(root_package, &compiled_unit)?;
        if compiled_package_info.build_flags.save_disassembly {
            on_disk_package.save_disassembly_to_disk(root_package, &compiled_unit)?;
        }
    }
    for (dep_name, compiled_unit) in deps_compiled_units {
        let dep_name: Symbol = dep_name.as_str().into();
        on_disk_package.save_compiled_unit(dep_name, &compiled_unit)?;
        if compiled_package_info.build_flags.save_disassembly {
            on_disk_package.save_disassembly_to_disk(dep_name, &compiled_unit)?;
        }
    }

    if let Some(docs) = compiled_docs {
        for (doc_filename, doc_contents) in docs {
            on_disk_package.save_under(
                CompiledPackageLayout::CompiledDocs
                    .path()
                    .join(doc_filename)
                    .with_extension("md"),
                doc_contents.clone().as_bytes(),
            )?;
        }
    }

    on_disk_package.save_under(
        CompiledPackageLayout::BuildInfo.path(),
        serde_yaml::to_string(&on_disk_package.package)?.as_bytes(),
    )?;

    Ok(on_disk_package)
}

/// There may be additional information that needs to be displayed after diagnostics are reported
/// (optionally report diagnostics themselves if files argument is provided).
pub fn decorate_warnings(warning_diags: Diagnostics, files: Option<&MappedFiles>) {
    let any_linter_warnings = warning_diags.any_with_prefix(LINT_WARNING_PREFIX);
    let (filtered_diags_num, unique) =
        warning_diags.filtered_source_diags_with_prefix(LINT_WARNING_PREFIX);
    if let Some(f) = files {
        report_warnings(f, warning_diags);
    }
    if any_linter_warnings {
        eprintln!("Please report feedback on the linter warnings at https://forums.sui.io\n");
    }
    if filtered_diags_num > 0 {
        eprintln!(
            "Total number of linter warnings suppressed: {filtered_diags_num} (unique lints: {unique})"
        );
    }
}

fn source_paths_for_config(package_path: &Path) -> Vec<PathBuf> {
    let mut places_to_look = Vec::new();
    let mut add_path = |layout_path: SourcePackageLayout| {
        let path = package_path.join(layout_path.path());
        if layout_path.is_optional() && !path.exists() {
            return;
        }
        places_to_look.push(path)
    };

    add_path(SourcePackageLayout::Sources);
    add_path(SourcePackageLayout::Scripts);

    places_to_look
        .into_iter()
        .filter(|path| path.exists())
        .collect()
}

// Find all the source files for a package at the given path
pub fn get_sources(path: &PackagePath) -> Result<Vec<FileName>> {
    let places_to_look = source_paths_for_config(path.path().as_path());
    Ok(find_move_filenames(&places_to_look, false)?
        .into_iter()
        .map(FileName::from)
        .collect())
}
